<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Packaging and Deploying Helm Charts with Guix | Polyedre</title>
<meta name=keywords content><meta name=description content="My daily job requires me to maintain multiple Helm Charts released to multiple Kubernetes Clusters.
I&rsquo;ve encountered mutiple limitations with Helm.
The Go templating engine sometimes is not enough. The only functions available to Chart Helm
maintainers have been added explicitely. You cannot add custom ones easily.
The values.yaml file is great at reducing the interface between the Helm Chart maintainer and the
users, but when an option is missing, the only ways are to fork or contribute a pull request, and
this lead to complex values.yaml Chart like those of bitnami (1427 lines):
https://github.com/bitnami/charts/blob/main/bitnami/argo-workflows/values.yaml."><meta name=author content="Polyedre"><link rel=canonical href=https://polyedre.github.io/posts/guix-helm-charts/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://polyedre.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://polyedre.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://polyedre.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://polyedre.github.io/apple-touch-icon.png><link rel=mask-icon href=https://polyedre.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://polyedre.github.io/posts/guix-helm-charts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-PL8DXXK8VN"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-PL8DXXK8VN")}</script><meta property="og:title" content="Packaging and Deploying Helm Charts with Guix"><meta property="og:description" content="My daily job requires me to maintain multiple Helm Charts released to multiple Kubernetes Clusters.
I&rsquo;ve encountered mutiple limitations with Helm.
The Go templating engine sometimes is not enough. The only functions available to Chart Helm
maintainers have been added explicitely. You cannot add custom ones easily.
The values.yaml file is great at reducing the interface between the Helm Chart maintainer and the
users, but when an option is missing, the only ways are to fork or contribute a pull request, and
this lead to complex values.yaml Chart like those of bitnami (1427 lines):
https://github.com/bitnami/charts/blob/main/bitnami/argo-workflows/values.yaml."><meta property="og:type" content="article"><meta property="og:url" content="https://polyedre.github.io/posts/guix-helm-charts/"><meta property="og:image" content="https://polyedre.github.io/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-04-01T00:00:00+00:00"><meta property="article:modified_time" content="2024-04-01T00:00:00+00:00"><meta property="og:site_name" content="Polyedre"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://polyedre.github.io/"><meta name=twitter:title content="Packaging and Deploying Helm Charts with Guix"><meta name=twitter:description content="My daily job requires me to maintain multiple Helm Charts released to multiple Kubernetes Clusters.
I&rsquo;ve encountered mutiple limitations with Helm.
The Go templating engine sometimes is not enough. The only functions available to Chart Helm
maintainers have been added explicitely. You cannot add custom ones easily.
The values.yaml file is great at reducing the interface between the Helm Chart maintainer and the
users, but when an option is missing, the only ways are to fork or contribute a pull request, and
this lead to complex values.yaml Chart like those of bitnami (1427 lines):
https://github.com/bitnami/charts/blob/main/bitnami/argo-workflows/values.yaml."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://polyedre.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Packaging and Deploying Helm Charts with Guix","item":"https://polyedre.github.io/posts/guix-helm-charts/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Packaging and Deploying Helm Charts with Guix","name":"Packaging and Deploying Helm Charts with Guix","description":"My daily job requires me to maintain multiple Helm Charts released to multiple Kubernetes Clusters.\nI\u0026rsquo;ve encountered mutiple limitations with Helm.\nThe Go templating engine sometimes is not enough. The only functions available to Chart Helm maintainers have been added explicitely. You cannot add custom ones easily.\nThe values.yaml file is great at reducing the interface between the Helm Chart maintainer and the users, but when an option is missing, the only ways are to fork or contribute a pull request, and this lead to complex values.yaml Chart like those of bitnami (1427 lines): https://github.com/bitnami/charts/blob/main/bitnami/argo-workflows/values.yaml.\n","keywords":[],"articleBody":"My daily job requires me to maintain multiple Helm Charts released to multiple Kubernetes Clusters.\nI’ve encountered mutiple limitations with Helm.\nThe Go templating engine sometimes is not enough. The only functions available to Chart Helm maintainers have been added explicitely. You cannot add custom ones easily.\nThe values.yaml file is great at reducing the interface between the Helm Chart maintainer and the users, but when an option is missing, the only ways are to fork or contribute a pull request, and this lead to complex values.yaml Chart like those of bitnami (1427 lines): https://github.com/bitnami/charts/blob/main/bitnami/argo-workflows/values.yaml.\nI recently watched a lot of talk from the Kubecon 2024 that happened at Paris, and I’ve been following the two Linux distributions Nix and Guix for a while (I mostly hoped to be able to generate minimalist Docker containers, but we are not there yet). As a result, my Youtube history led to a talk by Vladimir “farcaller” Pouzanov named NixCon2023 Nix and Kubernetes: Deployments Done Right.\nHe implemented a Nix Pkgs repository containing only Helm Charts. This allowed him to override Helm Chart configuration and resources without forking the Helm Chart. And finally, he was able to deploy all the Kubernetes YAML definitions to mutiple Kubernetes clusters using Argo-CD.\nAs a proud daily Emacs user, between Nix and Guix, my heart sways more towards Guix. I’m mostly interested in the fact that Guix is a complete programming language, while Nix is a DSL.\nThat’s why I’ve been working on a port of this talk to Guix!\nSee https://github.com/polyedre/guix-helm-charts.\nAfter a lot of trial an error, I was finally able to create a Helm Chart package that contains the raw Helm Chart:\n(define-public nginx-15.14.0 (package (name \"nginx\") (version \"15.14.0\") (source (origin (method url-fetch) (uri \"https://charts.bitnami.com/bitnami/nginx-15.14.0.tgz\") (sha256 #f))) (build-system copy-build-system) (home-page \"https://bitnami.com\") (synopsis \"NGINX Open Source is a web server that can be also used as a reverse proxy, load balancer, and HTTP cache. Recommended for high-demanding sites due to its ability to provide faster content.\") (description \"NGINX Open Source is a web server that can be also used as a reverse proxy, load balancer, and HTTP cache. Recommended for high-demanding sites due to its ability to provide faster content.\") (license #f))) With that, I could create a Helm Release from the Helm Chart by specifying a name to the release, a Namespace and some custom values:\n; This function generates a YAML file tree containing the definitions of the ; resources that would be applied when deploying the chart `chart` under the ; release name `name`, to the Kubernetes Namespace `namespace`, with the values ; `values`. The value argument must be a json object. (define (helm-release name chart namespace values) (with-imported-modules '((guix build utils)) (computed-file name #~(begin (use-modules (guix build utils)) (mkdir-p #$output) (system (format #f \"~a template ~a ~a --output-dir ~a --release-name --values ~a\" (string-append #$helm \"/bin/helm\") #$name #$chart #$output #$(plain-file \"values.json\" (scm-\u003ejson-string values)))))))) This function creates a Helm Release:\n(helm-release \"my-custom-release-name\" ilum-jupyter-6.1.0 \"default\" '((ingress . ((enabled . #t) (host . \"example.com\"))) To deploy the Helm release to a Kubernetes cluster, I only have to use kubectl apply:\nkubectl apply -f $(guix build -f example.scm) Multiple Helm Charts can be released together with the use of Guix’s directory-union method:\n(directory-union \"helm-releases\" (list (helm-release \"my-custom-release-name\" ilum-jupyter-6.1.0 \"default\" '((ingress . ((enabled . #t) (host . \"example.com\"))) (tolerations . #(((operator . \"Exists\")))))) (helm-release \"my-second\" ilum-jupyter-6.0.0 \"test\" '()) (helm-release \"another\" nginx-15.14.0 \"kubernetes-tools\" '()))) Using Guix has not been easy. I have some experience with emacs-lisp, so I was not afraid of the parenthesis or the functional programming paradigm. I mostly struggled to understand my errors because Guile does not always point to the failing line (probably because of the functional programming paradigm).\nAfter a lot of struggle, I discovered The Perfect Setup in Guix’s documentation. This is a page describing how to configure Emacs to develop with Guix. I was able to configure Geiser in Emacs, but something must be wrong about by load-path because the Geiser REPL was not able to import Guix modules.\nEdit: Thanks to @Z572@mastodon.social for pointing out that when working on Guile for Guix in Emacs, I can use command guix repl instead of guile. https://mastodon.social/@Z572/112195758829383364\n","wordCount":"694","inLanguage":"en","image":"https://polyedre.github.io/","datePublished":"2024-04-01T00:00:00Z","dateModified":"2024-04-01T00:00:00Z","author":{"@type":"Person","name":"Polyedre"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://polyedre.github.io/posts/guix-helm-charts/"},"publisher":{"@type":"Organization","name":"Polyedre","logo":{"@type":"ImageObject","url":"https://polyedre.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://polyedre.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://polyedre.github.io/profile.jpeg alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://polyedre.github.io/posts/ title=Posts><span>Posts</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://polyedre.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://polyedre.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Packaging and Deploying Helm Charts with Guix</h1><div class=post-meta><span title='2024-04-01 00:00:00 +0000 UTC'>April 1, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Polyedre&nbsp;|&nbsp;<a href=https://github.com/polyedre/polyedre.github.io/content/posts/guix-helm-charts.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>My daily job requires me to maintain multiple Helm Charts released to multiple Kubernetes Clusters.</p><p>I&rsquo;ve encountered mutiple limitations with Helm.</p><p>The Go templating engine sometimes is not enough. The only functions available to Chart Helm
maintainers have been added explicitely. You cannot add custom ones easily.</p><p>The values.yaml file is great at reducing the interface between the Helm Chart maintainer and the
users, but when an option is missing, the only ways are to fork or contribute a pull request, and
this lead to complex values.yaml Chart like those of bitnami (1427 lines):
<a href=https://github.com/bitnami/charts/blob/main/bitnami/argo-workflows/values.yaml>https://github.com/bitnami/charts/blob/main/bitnami/argo-workflows/values.yaml</a>.</p><p>I recently watched a lot of talk from the Kubecon 2024 that happened at Paris, and I&rsquo;ve been
following the two Linux distributions Nix and Guix for a while (I mostly hoped to be able to
generate minimalist Docker containers, but we are not there yet). As a result, my Youtube history
led to a talk by Vladimir &ldquo;farcaller&rdquo; Pouzanov named <a href="https://www.youtube.com/watch?v=SEA1Qm8K4gY">NixCon2023 Nix and Kubernetes: Deployments Done Right</a>.</p><p>He implemented a Nix Pkgs repository containing only Helm Charts. This allowed him to override Helm
Chart configuration and resources without forking the Helm Chart. And finally, he was able to
deploy all the Kubernetes YAML definitions to mutiple Kubernetes clusters using Argo-CD.</p><p>As a proud daily Emacs user, between Nix and Guix, my heart sways more towards Guix. I&rsquo;m mostly
interested in the fact that Guix is a complete programming language, while Nix is a DSL.</p><p>That&rsquo;s why I&rsquo;ve been working on a port of this talk to Guix!</p><p>See <a href=https://github.com/polyedre/guix-helm-charts>https://github.com/polyedre/guix-helm-charts</a>.</p><p>After a lot of trial an error, I was finally able to create a Helm Chart package that contains the
raw Helm Chart:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>(<span style=color:#a6e22e>define-public</span> nginx-15<span style=color:#f92672>.</span><span style=color:#ae81ff>14.0</span>
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>package</span>
</span></span><span style=display:flex><span>   (<span style=color:#a6e22e>name</span> <span style=color:#e6db74>&#34;nginx&#34;</span>)
</span></span><span style=display:flex><span>   (<span style=color:#a6e22e>version</span> <span style=color:#e6db74>&#34;15.14.0&#34;</span>)
</span></span><span style=display:flex><span>   (<span style=color:#a6e22e>source</span> (<span style=color:#a6e22e>origin</span>
</span></span><span style=display:flex><span>            (<span style=color:#a6e22e>method</span> url-fetch)
</span></span><span style=display:flex><span>            (<span style=color:#a6e22e>uri</span> <span style=color:#e6db74>&#34;https://charts.bitnami.com/bitnami/nginx-15.14.0.tgz&#34;</span>)
</span></span><span style=display:flex><span>            (<span style=color:#a6e22e>sha256</span> <span style=color:#66d9ef>#f</span>)))
</span></span><span style=display:flex><span>   (<span style=color:#a6e22e>build-system</span> copy-build-system)
</span></span><span style=display:flex><span>   (<span style=color:#a6e22e>home-page</span> <span style=color:#e6db74>&#34;https://bitnami.com&#34;</span>)
</span></span><span style=display:flex><span>   (<span style=color:#a6e22e>synopsis</span> <span style=color:#e6db74>&#34;NGINX Open Source is a web server that can be also used as a reverse proxy, load balancer, and HTTP cache. Recommended for high-demanding sites due to its ability to provide faster content.&#34;</span>)
</span></span><span style=display:flex><span>   (<span style=color:#a6e22e>description</span> <span style=color:#e6db74>&#34;NGINX Open Source is a web server that can be also used as a reverse proxy, load balancer, and HTTP cache. Recommended for high-demanding sites due to its ability to provide faster content.&#34;</span>)
</span></span><span style=display:flex><span>   (<span style=color:#a6e22e>license</span> <span style=color:#66d9ef>#f</span>)))
</span></span></code></pre></div><p>With that, I could create a Helm Release from the Helm Chart by specifying a name to the release, a
Namespace and some custom values:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span><span style=color:#75715e>; This function generates a YAML file tree containing the definitions of the</span>
</span></span><span style=display:flex><span><span style=color:#75715e>; resources that would be applied when deploying the chart `chart` under the</span>
</span></span><span style=display:flex><span><span style=color:#75715e>; release name `name`, to the Kubernetes Namespace `namespace`, with the values</span>
</span></span><span style=display:flex><span><span style=color:#75715e>; `values`. The value argument must be a json object.</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>define </span>(<span style=color:#a6e22e>helm-release</span> name chart namespace values)
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>with-imported-modules</span> <span style=color:#f92672>&#39;</span>((<span style=color:#a6e22e>guix</span> build utils))
</span></span><span style=display:flex><span>      (<span style=color:#a6e22e>computed-file</span> name
</span></span><span style=display:flex><span>         <span style=color:#f92672>#</span>~(<span style=color:#a6e22e>begin</span>
</span></span><span style=display:flex><span>           (<span style=color:#a6e22e>use-modules</span> (<span style=color:#a6e22e>guix</span> build utils))
</span></span><span style=display:flex><span>           (<span style=color:#a6e22e>mkdir-p</span> <span style=color:#f92672>#</span>$output)
</span></span><span style=display:flex><span>           (<span style=color:#a6e22e>system</span> (<span style=color:#a6e22e>format</span> <span style=color:#66d9ef>#f</span> <span style=color:#e6db74>&#34;~a template ~a ~a --output-dir ~a --release-name --values ~a&#34;</span>
</span></span><span style=display:flex><span>                    (string-append <span style=color:#f92672>#</span>$helm <span style=color:#e6db74>&#34;/bin/helm&#34;</span>)
</span></span><span style=display:flex><span>                    <span style=color:#f92672>#</span>$name
</span></span><span style=display:flex><span>                    <span style=color:#f92672>#</span>$chart
</span></span><span style=display:flex><span>                    <span style=color:#f92672>#</span>$output
</span></span><span style=display:flex><span>                    <span style=color:#f92672>#</span>$(<span style=color:#a6e22e>plain-file</span> <span style=color:#e6db74>&#34;values.json&#34;</span> (<span style=color:#a6e22e>scm-&gt;json-string</span> values))))))))
</span></span></code></pre></div><p>This function creates a Helm Release:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=display:flex><span>(<span style=color:#a6e22e>helm-release</span> <span style=color:#e6db74>&#34;my-custom-release-name&#34;</span> ilum-jupyter-6<span style=color:#f92672>.</span><span style=color:#ae81ff>1.0</span> <span style=color:#e6db74>&#34;default&#34;</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>&#39;</span>((<span style=color:#a6e22e>ingress</span> <span style=color:#f92672>.</span> ((<span style=color:#a6e22e>enabled</span> <span style=color:#f92672>.</span> <span style=color:#66d9ef>#t</span>)
</span></span><span style=display:flex><span>                              (<span style=color:#a6e22e>host</span> <span style=color:#f92672>.</span> <span style=color:#e6db74>&#34;example.com&#34;</span>)))
</span></span></code></pre></div><p>To deploy the Helm release to a Kubernetes cluster, I only have to use <code>kubectl apply</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl apply -f <span style=color:#66d9ef>$(</span>guix build -f example.scm<span style=color:#66d9ef>)</span>
</span></span></code></pre></div><p>Multiple Helm Charts can be released together with the use of Guix&rsquo;s <code>directory-union</code> method:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#f92672>(</span>directory-union <span style=color:#e6db74>&#34;helm-releases&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>(</span>list
</span></span><span style=display:flex><span>    <span style=color:#f92672>(</span>helm-release <span style=color:#e6db74>&#34;my-custom-release-name&#34;</span> ilum-jupyter-6.1.0 <span style=color:#e6db74>&#34;default&#34;</span>
</span></span><span style=display:flex><span>                  <span style=color:#e6db74>&#39;((ingress . ((enabled . #t)
</span></span></span><span style=display:flex><span><span style=color:#e6db74>                                (host . &#34;example.com&#34;)))
</span></span></span><span style=display:flex><span><span style=color:#e6db74>                    (tolerations . #(((operator . &#34;Exists&#34;))))))
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    (helm-release &#34;my-second&#34; ilum-jupyter-6.0.0 &#34;test&#34; &#39;</span><span style=color:#f92672>())</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>(</span>helm-release <span style=color:#e6db74>&#34;another&#34;</span> nginx-15.14.0 <span style=color:#e6db74>&#34;kubernetes-tools&#34;</span> <span style=color:#960050;background-color:#1e0010>&#39;</span><span style=color:#f92672>())))</span>
</span></span></code></pre></div><p>Using Guix has not been easy. I have some experience with emacs-lisp, so I was not afraid of the
parenthesis or the functional programming paradigm. I mostly struggled to understand my errors
because Guile does not always point to the failing line (probably because of the functional
programming paradigm).</p><p>After a lot of struggle, I discovered <a href=https://guix.gnu.org/manual/en/html_node/The-Perfect-Setup.html>The Perfect
Setup</a> in Guix&rsquo;s documentation.
This is a page describing how to configure Emacs to develop with Guix. I was able to configure
Geiser in Emacs, but something must be wrong about by load-path because the Geiser REPL was not able
to import Guix modules.</p><p>Edit: Thanks to @Z572@mastodon.social for pointing out that when working on Guile for Guix in Emacs,
I can use command <code>guix repl</code> instead of <code>guile</code>. <a href=https://mastodon.social/@Z572/112195758829383364>https://mastodon.social/@Z572/112195758829383364</a></p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://polyedre.github.io/posts/why-2767-nodeports/><span class=title>« Prev</span><br><span>Why Kubernetes NodePort Stops at 32767?</span>
</a><a class=next href=https://polyedre.github.io/posts/filter-metrics/><span class=title>Next »</span><br><span>Let's filter Prometheus metrics exposed by Softwares</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://polyedre.github.io/>Polyedre</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>