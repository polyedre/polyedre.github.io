<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Using multiple kubectl contexts at the same time | Polyedre</title>
<meta name=keywords content><meta name=description content="Kubernetes clusters rarely come alone. If you have access to at least one, in no time you&rsquo;ll need to switch your kubectl context to access other clusters.
But what if you need to access two clusters simultaneously?
This is a problem I had multiple times per week (even per day) for a few months. When comparing two Kubernetes clusters, if often had to switch the kubectl context between each command."><meta name=author content="Polyedre"><link rel=canonical href=https://polyedre.github.io/posts/ktx/><link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style><link rel=preload href=/profile.jpeg as=image><script defer crossorigin=anonymous src=/assets/js/highlight.min.2eadbb982468c11a433a3e291f01326f2ba43f065e256bf792dbd79640a92316.js integrity="sha256-Lq27mCRowRpDOj4pHwEybyukPwZeJWv3ktvXlkCpIxY=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://polyedre.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://polyedre.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://polyedre.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://polyedre.github.io/apple-touch-icon.png><link rel=mask-icon href=https://polyedre.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.124.1"><link rel=alternate hreflang=en href=https://polyedre.github.io/posts/ktx/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-PL8DXXK8VN"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-PL8DXXK8VN",{anonymize_ip:!1})}</script><meta property="og:title" content="Using multiple kubectl contexts at the same time"><meta property="og:description" content="Kubernetes clusters rarely come alone. If you have access to at least one, in no time you&rsquo;ll need to switch your kubectl context to access other clusters.
But what if you need to access two clusters simultaneously?
This is a problem I had multiple times per week (even per day) for a few months. When comparing two Kubernetes clusters, if often had to switch the kubectl context between each command."><meta property="og:type" content="article"><meta property="og:url" content="https://polyedre.github.io/posts/ktx/"><meta property="og:image" content="https://polyedre.github.io/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-07-15T00:00:00+00:00"><meta property="article:modified_time" content="2023-07-15T00:00:00+00:00"><meta property="og:site_name" content="Polyedre"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://polyedre.github.io/"><meta name=twitter:title content="Using multiple kubectl contexts at the same time"><meta name=twitter:description content="Kubernetes clusters rarely come alone. If you have access to at least one, in no time you&rsquo;ll need to switch your kubectl context to access other clusters.
But what if you need to access two clusters simultaneously?
This is a problem I had multiple times per week (even per day) for a few months. When comparing two Kubernetes clusters, if often had to switch the kubectl context between each command."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://polyedre.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Using multiple kubectl contexts at the same time","item":"https://polyedre.github.io/posts/ktx/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Using multiple kubectl contexts at the same time","name":"Using multiple kubectl contexts at the same time","description":"Kubernetes clusters rarely come alone. If you have access to at least one, in no time you\u0026rsquo;ll need to switch your kubectl context to access other clusters.\nBut what if you need to access two clusters simultaneously?\nThis is a problem I had multiple times per week (even per day) for a few months. When comparing two Kubernetes clusters, if often had to switch the kubectl context between each command.","keywords":[],"articleBody":"Kubernetes clusters rarely come alone. If you have access to at least one, in no time you’ll need to switch your kubectl context to access other clusters.\nBut what if you need to access two clusters simultaneously?\nThis is a problem I had multiple times per week (even per day) for a few months. When comparing two Kubernetes clusters, if often had to switch the kubectl context between each command.\n$ # Some pod cannot start on clusterA, let's compare the quota allocated on clusterB $ kubetctx clusterA $ kubectl get quota $ kubectx clusterB $ kubectl get quota $ # No difference constated, let's check if the number of replica is different $ kubetctx clusterA $ kubectl get deploy $ kubectx clusterB $ kubectl get deploy $ # Etc To reduce the number of context switching, I need to be able to start two terminals: one by kubectl context.\nHere is my quick solution (I use ZSH, so the autocompletion will not work if you use bash or fish):\nktx-init() { current_context=$(cat ~/.kube/config | yq '.current-context') for context in $(cat ~/.kube/config | yq '.contexts[].name'); do KUBECONFIG=~/.kube/config kubectx $context cp ~/.kube/config /tmp/k8s_context_$context done KUBECONFIG=~/.kube/config kubectx $current_context } ktx() { export KUBECONFIG=/tmp/k8s_context_$1 } _ktx() { compadd \"$@\" $(ls /tmp | grep k8s_context | sed 's/k8s_context_//') } compdef _ktx ktx After sourcing your ZSH config again, run the ktx-init command. It reads all the context stored in your file ~/.kube/config and create a kubeconfig file for each context.\nAfter, you can just switch context in each of the terminals with ktx .\nI did not expect this improvement to my workflow to be this easy. If I had known I would have written this function months ago!\n","wordCount":"285","inLanguage":"en","datePublished":"2023-07-15T00:00:00Z","dateModified":"2023-07-15T00:00:00Z","author":{"@type":"Person","name":"Polyedre"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://polyedre.github.io/posts/ktx/"},"publisher":{"@type":"Organization","name":"Polyedre","logo":{"@type":"ImageObject","url":"https://polyedre.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://polyedre.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://polyedre.github.io/profile.jpeg alt=logo aria-label=logo height=35>Home</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></span></div><ul id=menu><li><a href=https://polyedre.github.io/posts/ title=Posts><span>Posts</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://polyedre.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://polyedre.github.io/posts/>Posts</a></div><h1 class=post-title>Using multiple kubectl contexts at the same time</h1><div class=post-meta>&lt;span title='2023-07-15 00:00:00 +0000 UTC'>July 15, 2023&lt;/span>&amp;nbsp;·&amp;nbsp;2 min&amp;nbsp;·&amp;nbsp;Polyedre&nbsp;|&nbsp;<a href=https://github.com/polyedre/polyedre.github.io/content/posts/ktx.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>Kubernetes clusters rarely come alone. If you have access to at least one, in no
time you&rsquo;ll need to switch your kubectl context to access other clusters.</p><p>But what if you need to access two clusters <em>simultaneously</em>?</p><p>This is a problem I had multiple times per week (even per day) for a few months.
When comparing two Kubernetes clusters, if often had to switch the kubectl context
between each command.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>$ <span style=color:#75715e># Some pod cannot start on clusterA, let&#39;s compare the quota allocated on clusterB</span>
</span></span><span style=display:flex><span>$ kubetctx clusterA
</span></span><span style=display:flex><span>$ kubectl get quota
</span></span><span style=display:flex><span>$ kubectx clusterB
</span></span><span style=display:flex><span>$ kubectl get quota
</span></span><span style=display:flex><span>$ <span style=color:#75715e># No difference constated, let&#39;s check if the number of replica is different</span>
</span></span><span style=display:flex><span>$ kubetctx clusterA
</span></span><span style=display:flex><span>$ kubectl get deploy
</span></span><span style=display:flex><span>$ kubectx clusterB
</span></span><span style=display:flex><span>$ kubectl get deploy
</span></span><span style=display:flex><span>$ <span style=color:#75715e># Etc</span>
</span></span></code></pre></div><p>To reduce the number of context switching, I need to be able to start two
terminals: one by kubectl context.</p><p>Here is my quick solution (I use ZSH, so the autocompletion will not work if you
use bash or fish):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>ktx-init<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  current_context<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>cat ~/.kube/config | yq <span style=color:#e6db74>&#39;.current-context&#39;</span><span style=color:#66d9ef>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> context in <span style=color:#66d9ef>$(</span>cat ~/.kube/config | yq <span style=color:#e6db74>&#39;.contexts[].name&#39;</span><span style=color:#66d9ef>)</span>; <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>    KUBECONFIG<span style=color:#f92672>=</span>~/.kube/config kubectx $context
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    cp ~/.kube/config /tmp/k8s_context_$context
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>done</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  KUBECONFIG<span style=color:#f92672>=</span>~/.kube/config kubectx $current_context
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>ktx<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  export KUBECONFIG<span style=color:#f92672>=</span>/tmp/k8s_context_$1
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>_ktx<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  compadd <span style=color:#e6db74>&#34;</span>$@<span style=color:#e6db74>&#34;</span> <span style=color:#66d9ef>$(</span>ls /tmp | grep k8s_context | sed <span style=color:#e6db74>&#39;s/k8s_context_//&#39;</span><span style=color:#66d9ef>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>compdef _ktx ktx
</span></span></code></pre></div><p>After sourcing your ZSH config again, run the <code>ktx-init</code> command. It reads all
the context stored in your file <code>~/.kube/config</code> and create a kubeconfig file for
each context.</p><p>After, you can just switch context in each of the terminals with <code>ktx &lt;CONTEXT-NAME></code>.</p><p>I did not expect this improvement to my workflow to be this easy. If I had known
I would have written this function months ago!</p></div><footer class=post-footer><nav class=paginav><a class=prev href=https://polyedre.github.io/posts/filter-metrics/><span class=title>« Prev Page</span><br><span>Let's filter Prometheus metrics exposed by Softwares</span>
</a><a class=next href=https://polyedre.github.io/posts/scaling-kube-state-metrics/><span class=title>Next Page »</span><br><span>Reduce Kube State Metrics's sample count by 45%</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://polyedre.github.io/>Polyedre</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>