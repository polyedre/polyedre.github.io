<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Reduce Kube State Metrics's sample count by 45% | Polyedre</title><meta name=keywords content><meta name=description content="Kube State Metrics is a service that listen to the Kubernetes API server and generates metrics about the state of the resources (Pods, Deployments, Namespaces&mldr;). The metrics are exported on the HTTP endpoint /metrics on the listening port (default 8080). They are served as plaintext and can be crawled directly by Prometheus.
For each Kubernetes resource, some metrics are available. For Pods for instance, the metrics listed in this file are available."><meta name=author content="Polyedre"><link rel=canonical href=https://polyedre.github.io/posts/scaling-kube-state-metrics/><link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style><link rel=preload href=/profile.jpeg as=image><script defer crossorigin=anonymous src=/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js integrity="sha256-uVus3DnjejMqn4g7Hni+Srwf3KK8HyZB9V4809q9TWE=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://polyedre.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://polyedre.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://polyedre.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://polyedre.github.io/apple-touch-icon.png><link rel=mask-icon href=https://polyedre.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.112.6"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-PL8DXXK8VN"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-PL8DXXK8VN",{anonymize_ip:!1})}</script><meta property="og:title" content="Reduce Kube State Metrics's sample count by 45%"><meta property="og:description" content="Kube State Metrics is a service that listen to the Kubernetes API server and generates metrics about the state of the resources (Pods, Deployments, Namespaces&mldr;). The metrics are exported on the HTTP endpoint /metrics on the listening port (default 8080). They are served as plaintext and can be crawled directly by Prometheus.
For each Kubernetes resource, some metrics are available. For Pods for instance, the metrics listed in this file are available."><meta property="og:type" content="article"><meta property="og:url" content="https://polyedre.github.io/posts/scaling-kube-state-metrics/"><meta property="og:image" content="https://polyedre.github.io/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-05-31T19:41:17+01:00"><meta property="article:modified_time" content="2023-05-31T19:41:17+01:00"><meta property="og:site_name" content="Polyedre"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://polyedre.github.io/"><meta name=twitter:title content="Reduce Kube State Metrics's sample count by 45%"><meta name=twitter:description content="Kube State Metrics is a service that listen to the Kubernetes API server and generates metrics about the state of the resources (Pods, Deployments, Namespaces&mldr;). The metrics are exported on the HTTP endpoint /metrics on the listening port (default 8080). They are served as plaintext and can be crawled directly by Prometheus.
For each Kubernetes resource, some metrics are available. For Pods for instance, the metrics listed in this file are available."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://polyedre.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Reduce Kube State Metrics's sample count by 45%","item":"https://polyedre.github.io/posts/scaling-kube-state-metrics/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Reduce Kube State Metrics's sample count by 45%","name":"Reduce Kube State Metrics\u0027s sample count by 45%","description":"Kube State Metrics is a service that listen to the Kubernetes API server and generates metrics about the state of the resources (Pods, Deployments, Namespaces\u0026hellip;). The metrics are exported on the HTTP endpoint /metrics on the listening port (default 8080). They are served as plaintext and can be crawled directly by Prometheus.\nFor each Kubernetes resource, some metrics are available. For Pods for instance, the metrics listed in this file are available.","keywords":[],"articleBody":"Kube State Metrics is a service that listen to the Kubernetes API server and generates metrics about the state of the resources (Pods, Deployments, Namespaces…). The metrics are exported on the HTTP endpoint /metrics on the listening port (default 8080). They are served as plaintext and can be crawled directly by Prometheus.\nFor each Kubernetes resource, some metrics are available. For Pods for instance, the metrics listed in this file are available. This includes kube_pod_info and kube_pod_status_phase.\nEach line represent a metric in the output of a request to the HTTP endpoint. The more Kubernetes resources there are, the more metrics there are, and the larger the endpoint crawl result. With big Kubernetes clusters, the HTTP endpoint can return about one million lines of metrics.\nThis is a problem because Prometheus needs to crawl the endpoint regularly, and 20 seconds is a good frequency. But when the endpoint is too large, the HTTP request can take many seconds. Before the time needed to crawl the endpoint exceeds 20 seconds, it’s time to clean up the metrics exported by Kube State Metrics.\nFortunately, Kube State Metrics lets you limit the number of metrics exported in two different ways.\nChoose the Kubernetes resource to export Kube State Metrics allows you to enable or disable the export of metrics associated with each Kubernetes resource type. This is configured in the Helm chart with the collectors variable:\ncollectors: - certificatesigningrequests - configmaps - cronjobs - daemonsets - deployments - endpoints - horizontalpodautoscalers - ingresses - jobs - leases - pods [skipped] This is by far the easiest way to reduce the number of metrics.\nBlock useless metrics from being exported But what if I’m not interested in kube_pod_info but use kube_pod_status_phase ? It is not possible to disable the collector for the Pods because otherwise kube_pod_status_phase would not be exported.\nTo manage metrics individually, Kube State Metrics allows to block some metrics explicitely. This is configurable in the Helm Chart with the metricDenylist variable:\nmetricDenyList: - kube_*_info - kube_pod_status_qos_class Identifying unused metrics Identifying the unused metrics is the boring part of the process. The ideal would be to extract the list of all metrics used by the Grafana Dashboards. In practice, it depends of the organization.\nOn the clusters I worked with, I was able to identify about half of the metrics as useless. After rolling out the Helm Chart with the new values, the CPU and memory usage dropped by about 20% and the size of the HTTP response has been reduced by about 45%.\nThe time to crawl the HTTP endpoint became far more manageable. The users can continue to deploy new Kubernetes resources without worries.\nAn alternative to reduce the size of a crawl There is an other approach to reduce the size of a crawl and avoid the 20 seconds limit. Kube State Metrics can scale horizontally by sharding the metrics between the different Pods.\nWhen the sharding is enabled in the Helm Chart, the Deployment is replaced by a StatefulSet, and the Service by a Headless Service. Each pod is started with the two flags --shard and --total-shards .\nThis approach could have been an option if removing a lot of unused metrics from the export would not have been possible.\n","wordCount":"543","inLanguage":"en","datePublished":"2023-05-31T19:41:17+01:00","dateModified":"2023-05-31T19:41:17+01:00","author":{"@type":"Person","name":"Polyedre"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://polyedre.github.io/posts/scaling-kube-state-metrics/"},"publisher":{"@type":"Organization","name":"Polyedre","logo":{"@type":"ImageObject","url":"https://polyedre.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://polyedre.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://polyedre.github.io/profile.jpeg alt=logo aria-label=logo height=35>Home</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://polyedre.github.io/posts/ title=Posts><span>Posts</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://polyedre.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://polyedre.github.io/posts/>Posts</a></div><h1 class=post-title>Reduce Kube State Metrics's sample count by 45%</h1><div class=post-meta><span title='2023-05-31 19:41:17 +0100 +0100'>May 31, 2023</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Polyedre&nbsp;|&nbsp;<a href=https://github.com/polyedre/polyedre.github.io/content/posts/scaling-kube-state-metrics.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p><a href=https://github.com/kubernetes/kube-state-metrics>Kube State Metrics</a> is a
service that listen to the Kubernetes API server and generates metrics about the
state of the resources (Pods, Deployments, Namespaces&mldr;).
The metrics are exported on the HTTP endpoint <code>/metrics</code> on the listening port
(default 8080). They are served as plaintext and can be crawled directly by
Prometheus.</p><p>For each Kubernetes resource, some metrics are available. For Pods for
instance, the metrics listed in <a href=https://github.com/kubernetes/kube-state-metrics/blob/main/docs/pod-metrics.md>this
file</a>
are available. This includes <code>kube_pod_info</code> and <code>kube_pod_status_phase</code>.</p><p>Each line represent a metric in the output of a request to the HTTP endpoint.
The more Kubernetes resources there are, the more metrics there are, and the
larger the endpoint crawl result. With big Kubernetes clusters, the HTTP
endpoint can return about one million lines of metrics.</p><p>This is a problem because Prometheus needs to crawl the endpoint regularly, and
20 seconds is a good frequency. But when the endpoint is too large, the HTTP
request can take many seconds. Before the time needed to crawl the endpoint
exceeds 20 seconds, it&rsquo;s time to clean up the metrics exported by Kube State
Metrics.</p><p>Fortunately, Kube State Metrics lets you limit the number of metrics exported in two different ways.</p><h2 id=choose-the-kubernetes-resource-to-export>Choose the Kubernetes resource to export<a hidden class=anchor aria-hidden=true href=#choose-the-kubernetes-resource-to-export>#</a></h2><p>Kube State Metrics allows you to enable or disable the export of metrics
associated with each Kubernetes resource type. This is configured in the Helm
chart with the <code>collectors</code> variable:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>collectors</span>:
</span></span><span style=display:flex><span>  - <span style=color:#ae81ff>certificatesigningrequests</span>
</span></span><span style=display:flex><span>  - <span style=color:#ae81ff>configmaps</span>
</span></span><span style=display:flex><span>  - <span style=color:#ae81ff>cronjobs</span>
</span></span><span style=display:flex><span>  - <span style=color:#ae81ff>daemonsets</span>
</span></span><span style=display:flex><span>  - <span style=color:#ae81ff>deployments</span>
</span></span><span style=display:flex><span>  - <span style=color:#ae81ff>endpoints</span>
</span></span><span style=display:flex><span>  - <span style=color:#ae81ff>horizontalpodautoscalers</span>
</span></span><span style=display:flex><span>  - <span style=color:#ae81ff>ingresses</span>
</span></span><span style=display:flex><span>  - <span style=color:#ae81ff>jobs</span>
</span></span><span style=display:flex><span>  - <span style=color:#ae81ff>leases</span>
</span></span><span style=display:flex><span>  - <span style=color:#ae81ff>pods</span>
</span></span><span style=display:flex><span>[<span style=color:#ae81ff>skipped]</span>
</span></span></code></pre></div><p>This is by far the easiest way to reduce the number of metrics.</p><h2 id=block-useless-metrics-from-being-exported>Block useless metrics from being exported<a hidden class=anchor aria-hidden=true href=#block-useless-metrics-from-being-exported>#</a></h2><p>But what if I&rsquo;m not interested in <code>kube_pod_info</code> but use
<code>kube_pod_status_phase</code> ? It is not possible to disable the collector for the
Pods because otherwise <code>kube_pod_status_phase</code> would not be exported.</p><p>To manage metrics individually, Kube State Metrics allows to block some metrics
explicitely. This is configurable in the Helm Chart with the <code>metricDenylist</code> variable:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>metricDenyList</span>:
</span></span><span style=display:flex><span>  - <span style=color:#ae81ff>kube_*_info</span>
</span></span><span style=display:flex><span>  - <span style=color:#ae81ff>kube_pod_status_qos_class</span>
</span></span></code></pre></div><h2 id=identifying-unused-metrics>Identifying unused metrics<a hidden class=anchor aria-hidden=true href=#identifying-unused-metrics>#</a></h2><p>Identifying the unused metrics is the boring part of the process. The ideal
would be to extract the list of all metrics used by the Grafana Dashboards. In
practice, it depends of the organization.</p><p>On the clusters I worked with, I was able to identify about half of the metrics
as useless. After rolling out the Helm Chart with the new values, the CPU and
memory usage dropped by about 20% and the size of the HTTP response has been
reduced by about 45%.</p><p>The time to crawl the HTTP endpoint became far more manageable. The users can
continue to deploy new Kubernetes resources without worries.</p><h2 id=an-alternative-to-reduce-the-size-of-a-crawl>An alternative to reduce the size of a crawl<a hidden class=anchor aria-hidden=true href=#an-alternative-to-reduce-the-size-of-a-crawl>#</a></h2><p>There is an other approach to reduce the size of a crawl and avoid the 20
seconds limit. Kube State Metrics can scale horizontally by sharding the metrics
between the different Pods.</p><p>When the sharding is enabled in the Helm Chart, the Deployment is replaced by a
StatefulSet, and the Service by a Headless Service. Each pod is started with the
two flags <code>--shard &lt;id></code> and <code>--total-shards &lt;count></code>.</p><p>This approach could have been an option if removing a lot of unused metrics from
the export would not have been possible.</p></div><footer class=post-footer><nav class=paginav><a class=next href=https://polyedre.github.io/posts/dive/><span class=title>Next Page »</span><br><span>Identifying unused files in Docker images with Dive</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://polyedre.github.io/>Polyedre</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>