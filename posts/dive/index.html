<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Identifying unused files in Docker images with Dive | Polyedre</title>
<meta name=keywords content><meta name=description content="One of the challenges of using Docker is that images can often be quite large, especially for interpreted languages. Large Docker images increase pull time and disk space usage, making it difficult to manage and deploy applications. In this article, we&rsquo;ll take a look at a tool called &ldquo;dive&rdquo; that can help to optimize the size of Docker images.
Dive is a command-line tool that allows users to analyze the addition of each layer to the filesystem of a Docker image. This information can be used to identify unused or unnecessary files, which can then be removed to reduce the size of the image. Let&rsquo;s take a look at how I used dive to optimize the size of the Docker image for the open-source web scanner Wapiti."><meta name=author content="Polyedre"><link rel=canonical href=https://polyedre.github.io/posts/dive/><link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style><link rel=preload href=/profile.jpeg as=image><script defer crossorigin=anonymous src=/assets/js/highlight.min.2eadbb982468c11a433a3e291f01326f2ba43f065e256bf792dbd79640a92316.js integrity="sha256-Lq27mCRowRpDOj4pHwEybyukPwZeJWv3ktvXlkCpIxY=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://polyedre.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://polyedre.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://polyedre.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://polyedre.github.io/apple-touch-icon.png><link rel=mask-icon href=https://polyedre.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.134.3"><link rel=alternate hreflang=en href=https://polyedre.github.io/posts/dive/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-PL8DXXK8VN"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-PL8DXXK8VN")}</script><meta property="og:title" content="Identifying unused files in Docker images with Dive"><meta property="og:description" content="One of the challenges of using Docker is that images can often be quite large, especially for interpreted languages. Large Docker images increase pull time and disk space usage, making it difficult to manage and deploy applications. In this article, we&rsquo;ll take a look at a tool called &ldquo;dive&rdquo; that can help to optimize the size of Docker images.
Dive is a command-line tool that allows users to analyze the addition of each layer to the filesystem of a Docker image. This information can be used to identify unused or unnecessary files, which can then be removed to reduce the size of the image. Let&rsquo;s take a look at how I used dive to optimize the size of the Docker image for the open-source web scanner Wapiti."><meta property="og:type" content="article"><meta property="og:url" content="https://polyedre.github.io/posts/dive/"><meta property="og:image" content="https://polyedre.github.io/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-12-10T12:57:17+01:00"><meta property="article:modified_time" content="2022-12-10T12:57:17+01:00"><meta property="og:site_name" content="Polyedre"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://polyedre.github.io/"><meta name=twitter:title content="Identifying unused files in Docker images with Dive"><meta name=twitter:description content="One of the challenges of using Docker is that images can often be quite large, especially for interpreted languages. Large Docker images increase pull time and disk space usage, making it difficult to manage and deploy applications. In this article, we&rsquo;ll take a look at a tool called &ldquo;dive&rdquo; that can help to optimize the size of Docker images.
Dive is a command-line tool that allows users to analyze the addition of each layer to the filesystem of a Docker image. This information can be used to identify unused or unnecessary files, which can then be removed to reduce the size of the image. Let&rsquo;s take a look at how I used dive to optimize the size of the Docker image for the open-source web scanner Wapiti."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://polyedre.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Identifying unused files in Docker images with Dive","item":"https://polyedre.github.io/posts/dive/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Identifying unused files in Docker images with Dive","name":"Identifying unused files in Docker images with Dive","description":"One of the challenges of using Docker is that images can often be quite large, especially for interpreted languages. Large Docker images increase pull time and disk space usage, making it difficult to manage and deploy applications. In this article, we\u0026rsquo;ll take a look at a tool called \u0026ldquo;dive\u0026rdquo; that can help to optimize the size of Docker images.\nDive is a command-line tool that allows users to analyze the addition of each layer to the filesystem of a Docker image. This information can be used to identify unused or unnecessary files, which can then be removed to reduce the size of the image. Let\u0026rsquo;s take a look at how I used dive to optimize the size of the Docker image for the open-source web scanner Wapiti.\n","keywords":[],"articleBody":"One of the challenges of using Docker is that images can often be quite large, especially for interpreted languages. Large Docker images increase pull time and disk space usage, making it difficult to manage and deploy applications. In this article, we’ll take a look at a tool called “dive” that can help to optimize the size of Docker images.\nDive is a command-line tool that allows users to analyze the addition of each layer to the filesystem of a Docker image. This information can be used to identify unused or unnecessary files, which can then be removed to reduce the size of the image. Let’s take a look at how I used dive to optimize the size of the Docker image for the open-source web scanner Wapiti.\nUsing Dive To use dive, you’ll need to install it on your system. On Debian or Ubuntu, you can do this with the following command:\nwget https://github.com/wagoodman/dive/releases/download/v0.9.2/dive_0.9.2_linux_amd64.deb sudo apt install ./dive_0.9.2_linux_amd64.deb Once dive is installed, you can use it to analyze a Docker image by running the following command, where IMAGE_NAME is the name of the image you want to analyze:\ndive IMAGE_NAME This will launch the dive interface, which will show you a list of all the layers in the Docker image and the size of each layer. Dive is a text user interface (TUI) tool, so you can navigate the filesystem using the keyboard shortcuts at the bottom of the terminal.\nAnalyzing Wapiti with Dive Wapiti is a popular open-source web scanner that is used to identify vulnerabilities and security flaws in web applications. It is written in Python and uses a blackbox approach to testing, which means that it does not rely on the source code of the application being tested.\nInstead, Wapiti works by crawling the application and sending requests to the various URLs that it discovers. It then analyzes the responses from the application and looks for potential vulnerabilities, such as cross-site scripting (XSS) and SQL injection attacks.\nRecently, Wapiti added support for scanning single page websites. To do this, Wapiti needs to interpret JavaScript code and rely on Firefox headless. The Docker image for this version of Wapiti is quite large, as shown in the following example:\n$ docker image ls cyberwatch/wapiti-headless:latest REPOSITORY TAG IMAGE ID CREATED SIZE cyberwatch/wapiti-headless latest 815ece1118d6 3 days ago 682MB To analyze this image with dive, we can use the following command:\ndive cyberwatch/wapiti-headless:latest When browsing the layers, I noticed that two archives that were downloaded to install Firefox and Gecko Driver were still present in the final image.\nAfter removing these archives, the size of the Docker image was greatly reduced:\n$ docker image ls cyberwatch/wapiti-headless:latest REPOSITORY TAG IMAGE ID CREATED SIZE cyberwatch/wapiti-headless latest e642ae5ff5a7 4 minutes ago 582MB I submitted a pull request with the fix.\nConclusion In conclusion, the dive tool is a powerful and easy-to-use tool for optimizing and reducing the size of Docker images. By using the techniques discussed in this article, you can make your Docker images smaller and more efficient, which will make it easier to manage and deploy your containerized applications.\n","wordCount":"517","inLanguage":"en","datePublished":"2022-12-10T12:57:17+01:00","dateModified":"2022-12-10T12:57:17+01:00","author":{"@type":"Person","name":"Polyedre"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://polyedre.github.io/posts/dive/"},"publisher":{"@type":"Organization","name":"Polyedre","logo":{"@type":"ImageObject","url":"https://polyedre.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://polyedre.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://polyedre.github.io/profile.jpeg alt=logo aria-label=logo height=35>Home</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></span></div><ul id=menu><li><a href=https://polyedre.github.io/posts/ title=Posts><span>Posts</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://polyedre.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://polyedre.github.io/posts/>Posts</a></div><h1 class=post-title>Identifying unused files in Docker images with Dive</h1><div class=post-meta>&lt;span title='2022-12-10 12:57:17 +0100 +0100'>December 10, 2022&lt;/span>&amp;nbsp;·&amp;nbsp;3 min&amp;nbsp;·&amp;nbsp;Polyedre&nbsp;|&nbsp;<a href=https://github.com/polyedre/polyedre.github.io/content/posts/dive.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>One of the challenges of using Docker is that images can often be quite large, especially for interpreted languages. Large Docker images increase pull time and disk space usage, making it difficult to manage and deploy applications. In this article, we&rsquo;ll take a look at a tool called &ldquo;dive&rdquo; that can help to optimize the size of Docker images.</p><p>Dive is a command-line tool that allows users to analyze the addition of each layer to the filesystem of a Docker image. This information can be used to identify unused or unnecessary files, which can then be removed to reduce the size of the image. Let&rsquo;s take a look at how I used dive to optimize the size of the Docker image for the open-source web scanner Wapiti.</p><h2 id=using-dive>Using Dive<a hidden class=anchor aria-hidden=true href=#using-dive>#</a></h2><p>To use dive, you&rsquo;ll need to install it on your system. On Debian or Ubuntu, you can do this with the following command:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>wget https://github.com/wagoodman/dive/releases/download/v0.9.2/dive_0.9.2_linux_amd64.deb
</span></span><span style=display:flex><span>sudo apt install ./dive_0.9.2_linux_amd64.deb
</span></span></code></pre></div><p>Once dive is installed, you can use it to analyze a Docker image by running the following command, where IMAGE_NAME is the name of the image you want to analyze:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>dive IMAGE_NAME
</span></span></code></pre></div><p>This will launch the dive interface, which will show you a list of all the layers in the Docker image and the size of each layer. Dive is a text user interface (TUI) tool, so you can navigate the filesystem using the keyboard shortcuts at the bottom of the terminal.</p><h2 id=analyzing-wapiti-with-dive>Analyzing Wapiti with Dive<a hidden class=anchor aria-hidden=true href=#analyzing-wapiti-with-dive>#</a></h2><p>Wapiti is a popular open-source web scanner that is used to identify vulnerabilities and security flaws in web applications. It is written in Python and uses a blackbox approach to testing, which means that it does not rely on the source code of the application being tested.</p><p>Instead, Wapiti works by crawling the application and sending requests to the various URLs that it discovers. It then analyzes the responses from the application and looks for potential vulnerabilities, such as cross-site scripting (XSS) and SQL injection attacks.</p><p>Recently, Wapiti added support for scanning single page websites. To do this, Wapiti needs to interpret JavaScript code and rely on Firefox headless. The Docker image for this version of Wapiti is quite large, as shown in the following example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>$ docker image ls cyberwatch/wapiti-headless:latest
</span></span><span style=display:flex><span>REPOSITORY                   TAG       IMAGE ID       CREATED          SIZE
</span></span><span style=display:flex><span>cyberwatch/wapiti-headless   latest    815ece1118d6   <span style=color:#ae81ff>3</span> days ago       682MB
</span></span></code></pre></div><p>To analyze this image with dive, we can use the following command:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>dive cyberwatch/wapiti-headless:latest
</span></span></code></pre></div><p>When browsing the layers, I noticed that two archives that were downloaded to install Firefox and Gecko Driver were still present in the final image.</p><p><img loading=lazy src=wapiti-headless-useless-archives.png alt="!Dive interface showing that two archives takes 81MB!"></p><p>After removing these archives, the size of the Docker image was greatly reduced:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>$ docker image ls cyberwatch/wapiti-headless:latest
</span></span><span style=display:flex><span>REPOSITORY                   TAG       IMAGE ID       CREATED         SIZE
</span></span><span style=display:flex><span>cyberwatch/wapiti-headless   latest    e642ae5ff5a7   <span style=color:#ae81ff>4</span> minutes ago   582MB
</span></span></code></pre></div><p>I submitted a <a href=https://github.com/wapiti-scanner/wapiti/pull/342>pull request</a> with the fix.</p><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>In conclusion, the dive tool is a powerful and easy-to-use tool for optimizing
and reducing the size of Docker images. By using the techniques discussed in
this article, you can make your Docker images smaller and more efficient, which
will make it easier to manage and deploy your containerized applications.</p></div><footer class=post-footer><nav class=paginav><a class=prev href=https://polyedre.github.io/posts/scaling-kube-state-metrics/><span class=title>« Prev Page</span><br><span>Reduce Kube State Metrics's sample count by 45%</span>
</a><a class=next href=https://polyedre.github.io/posts/openpgp_2/><span class=title>Next Page »</span><br><span>À la recherche du workflow GPG parfait (Partie 2)</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://polyedre.github.io/>Polyedre</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>