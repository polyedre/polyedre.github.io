<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Polyedre</title>
    <link>https://polyedre.github.io/</link>
    <description>Recent content on Polyedre</description>
    <image>
      <url>https://polyedre.github.io/</url>
      <link>https://polyedre.github.io/</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Wed, 31 May 2023 19:41:17 +0100</lastBuildDate><atom:link href="https://polyedre.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Reduce Kube State Metrics&#39;s sample count by 45%</title>
      <link>https://polyedre.github.io/posts/scaling-kube-state-metrics/</link>
      <pubDate>Wed, 31 May 2023 19:41:17 +0100</pubDate>
      
      <guid>https://polyedre.github.io/posts/scaling-kube-state-metrics/</guid>
      <description>Kube State Metrics is a service that listen to the Kubernetes API server and generates metrics about the state of the resources (Pods, Deployments, Namespaces&amp;hellip;). The metrics are exported on the HTTP endpoint /metrics on the listening port (default 8080). They are served as plaintext and can be crawled directly by Prometheus.
For each Kubernetes resource, some metrics are available. For Pods for instance, the metrics listed in this file are available.</description>
    </item>
    
    <item>
      <title>Identifying unused files in Docker images with Dive</title>
      <link>https://polyedre.github.io/posts/dive/</link>
      <pubDate>Sat, 10 Dec 2022 12:57:17 +0100</pubDate>
      
      <guid>https://polyedre.github.io/posts/dive/</guid>
      <description>One of the challenges of using Docker is that images can often be quite large, especially for interpreted languages. Large Docker images increase pull time and disk space usage, making it difficult to manage and deploy applications. In this article, we&amp;rsquo;ll take a look at a tool called &amp;ldquo;dive&amp;rdquo; that can help to optimize the size of Docker images.
Dive is a command-line tool that allows users to analyze the addition of each layer to the filesystem of a Docker image.</description>
    </item>
    
    <item>
      <title>À la recherche du workflow GPG parfait (Partie 2)</title>
      <link>https://polyedre.github.io/posts/openpgp_2/</link>
      <pubDate>Fri, 29 Apr 2022 00:00:00 +0100</pubDate>
      
      <guid>https://polyedre.github.io/posts/openpgp_2/</guid>
      <description>Dans la partie précédente, j&amp;rsquo;ai créé une paire de clé GPG primaire sur un trousseau temporaire, puis 3 clés secondaires pour chaque usage : signer, chiffrer et authentifier. Je peux maintenant sauvegarder la clé primaire sur un support physique déconnecté d&amp;rsquo;internet et transférer les clés secondaires sur le trousseau système.
En cas de maintenance sur les clés secondaires, comme une extension de leur durée de validité ou encore leur renouvellement, il sera nécessaire d&amp;rsquo;utiliser la clé principale, et nous allons voir comment le faire.</description>
    </item>
    
    <item>
      <title>À la recherche du workflow GPG parfait (Partie 1)</title>
      <link>https://polyedre.github.io/posts/openpgp_1/</link>
      <pubDate>Tue, 29 Mar 2022 00:00:00 +0100</pubDate>
      
      <guid>https://polyedre.github.io/posts/openpgp_1/</guid>
      <description>Les outils pour créer des clés GPG existent depuis une vingtaine d&amp;rsquo;années maintenant, et pourtant la gestion des clés est toujours aussi rugueuse. Dans cet article je vais essayer de résumer tout ce que j&amp;rsquo;ai compris et mis en place pour respecter les Best Practices.
Pour résumer, après avoir configurer GPG, je vais créer une clé primaire, 3 sous-clés spécifiques à chaque usage puis la clé primaire sera sauvegardée sur un support offline et retirée du trousseau.</description>
    </item>
    
    <item>
      <title>Microk8s, multi-usage Kubernetes</title>
      <link>https://polyedre.github.io/posts/microk8s/</link>
      <pubDate>Sat, 12 Feb 2022 12:41:17 +0100</pubDate>
      
      <guid>https://polyedre.github.io/posts/microk8s/</guid>
      <description>Microk8s is a framework designed to start a Kubernetes cluster. According to Canonical, which maintain the project, it is production ready, requires low maintenance and the Kubernetes cluster uses minimal resources.
Microk8s is cross-platform and is available on Windows, Linux and macOS. One feature that is really cool is that it comes with a plugin system to enable some features in the cluster lovely easy.
It also supports ARM if you want to run a Kubernetes cluster on Raspberry Pies.</description>
    </item>
    
    <item>
      <title>Using multiple kubectl contexts at the same time</title>
      <link>https://polyedre.github.io/posts/ktx/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://polyedre.github.io/posts/ktx/</guid>
      <description>Kubernetes clusters rarely come alone. If you have access to at least one, in no time you&amp;rsquo;ll need to switch your kubectl context to access other clusters.
But what if you need to access two clusters simultaneously?
This is a problem I had multiple times per week (even per day) for a few months. When comparing two Kubernetes clusters, if often had to switch the kubectl context between each command.</description>
    </item>
    
  </channel>
</rss>
